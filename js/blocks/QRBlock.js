import { BaseBlock } from './BaseBlock.js';

export class QRBlock extends BaseBlock {
    constructor(manager) {
        super(manager, 'qr');

        // UI
        this.inputContainer = document.createElement('div');
        this.inputContainer.className = 'qr-input-container';

        this.input = document.createElement('input');
        this.input.type = 'text';
        this.input.placeholder = 'Enter URL or text...';
        this.input.className = 'qr-input';

        this.qrContainer = document.createElement('div');
        this.qrContainer.className = 'qr-preview';

        // Debounce generation
        let timeout;
        this.input.addEventListener('input', () => {
            clearTimeout(timeout);
            timeout = setTimeout(() => this.generateQR(), 300);
        });

        this.inputContainer.appendChild(this.input);
        this.content.appendChild(this.inputContainer);
        this.content.appendChild(this.qrContainer);

        // Initial text
        this.input.value = "https://example.com";
        setTimeout(() => this.generateQR(), 100);
    }

    generateQR() {
        const text = this.input.value;
        this.qrContainer.innerHTML = ''; // Clear previous

        if (!text) return;

        if (typeof QRCode === 'undefined') {
            this.qrContainer.innerText = 'Error: QRCode library missing';
            return;
        }

        try {
            // Generate QR Code
            // We use a fixed size for the preview.
            new QRCode(this.qrContainer, {
                text: text,
                width: 200,
                height: 200,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.H
            });
        } catch (e) {
            console.error(e);
        }
    }

    onPreviewMode(active) {
        if (active) {
            this.inputContainer.style.display = 'none';
        } else {
            this.inputContainer.style.display = 'block';
        }
    }

    async renderCanvas(options = {}) {
        const text = this.input.value;
        if (!text) return null;

        const paddingVertical = (options.paddingVertical || 0) * 8;
        // QR Block ignores horizontal padding for scaling (it's fixed 200px),
        // but acts as "margins" if we want strictly correct paper layout.
        // For now, let's keep it centered but add vertical padding.

        const qrSize = 200;
        const canvasHeight = qrSize + (paddingVertical * 2);

        const canvas = document.createElement('canvas');
        canvas.width = 384;
        canvas.height = canvasHeight;

        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 384, canvasHeight);

        // Grab the canvas generated by QRCode lib
        const srcCanvas = this.qrContainer.querySelector('canvas');
        const srcImg = this.qrContainer.querySelector('img');

        // Prefer canvas, fallback to img
        const source = srcCanvas || srcImg;

        if (source) {
            // Center horizontally: (384 - 200) / 2 = 92
            const x = (384 - qrSize) / 2;
            // Center vertically with padding: paddingVertical
            const y = paddingVertical;
            ctx.drawImage(source, x, y, qrSize, qrSize);
        } else {
            // Fallback: render error text
            ctx.fillStyle = 'black';
            ctx.font = '20px sans-serif';
            ctx.fillText('QR Code Error', 10, 50);
        }

        return canvas;
    }
}
